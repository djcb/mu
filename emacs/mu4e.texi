\input texinfo.tex    @c -*-texinfo-*-
@c %**start of header
@setfilename mu4e.info
@settitle mu4e user manual
@documentencoding utf-8
@c %**end of header
@include version.texi

@titlepage
@title @t{mu4e} - an e-mail client for emacs
@author{Dirk-Jan C. Binnema}
@end titlepage


@dircategory Emacs
@direntry
* mu4e: (mu4e).        An email client for emacs based on mu.
@end direntry
@copying
Copyright @copyright{} 2012 Dirk-Jan C. Binnema

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License.''
@end quotation
@end copying

@node Top
@top mu4e Manual

Welcome to @t{mu4e}!

@t{mu4e} (mu-for-emacs) is an e-mail client for GNU-Emacs, version 23 and
later, built on top of the @t{mu} e-mail search engine. @t{mu4e} is optimized
for fast handling of large amounts of e-mail.

Some of the features include:

@itemize
@item Fully search-based: there are no folders, only queries
@item Fully documented, with example configurations
@item UI optimized for speed with quick key strokes for common actions
@item Asynchronous: heavy actions never block @t{emacs}
@item Rich-text e-mails using @t{org-mode} (experimental)
@item Address auto-completion based on your messages -- no need for managing address books
@item Extendable using your own custom actions
@end itemize

This manual goes through the installation of @t{mu4e}, discusses the basic
configuration, and explains its daily use. It also shows how you can customize
@t{mu4e} for your needs. At the end of the manual, there are some example
configurations, which should help you to get up to speed quickly.

Also note the @xref{FAQ - Frequently Anticipated Questions}, and the section
on @xref{Known issues / missing features}, which may save you some time.

This manual has been updated for @t{mu}/@t{mu4e} version
@emph{@value{mu4e-version}}.

@menu
* Introduction:: How it all began
* Getting started:: Setting things up
* Running mu4e:: Daily use
* Searching:: Some more background on searching/queries
* Marking:: Marking messages and performing actions
* Actions:: Defining and using custom actions
* Interaction with other tools:: mu4e and the rest of the world
* Example configuration:: Some examples to set you up quickly
* FAQ - Frequently Anticipated Questions:: Common questions and answers
* Known issues / missing features:: mu4e is not perfect yet

Appendices
* How it works:: Some notes about the implementation of @t{mu4e}
* Logging and debugging:: How to debug problems in @t{mu4e}
* GNU Free Documentation License::  The license of this manual
@end menu

@node Introduction
@chapter Introduction

Welcome to @t{mu4e}!

@menu
* Why another e-mail client?::
* Other mail clients::
* What mu4e does not do::
@end menu

@node Why another e-mail client?
@section Why another e-mail client?

Fair question.

I'm not sure the world @emph{needs} yet another e-mail client, but perhaps
@emph{I} do! I (the author) spend a @emph{lot} of time, professionally and
privately, dealing with e-mail messdae and therefore, having an efficient
e-mail client is essential for me. Since none of the existing ones worked the
way I wanted, I created my own.

As @t{emacs} is such an integral part of my workflow, it made a lot of sense
to integrate my e-mail client with it. And as I already had written an e-mail
search engine (@t{mu}), it seemed only logical to use that as a basis.

Even though I created @t{mu4e} for such selfish reasons, @t{mu4e} tries hard
to be as useful as possible for @emph{all} its users - suggestions are very
welcome and many have already made it to @t{mu4e}.

@node Other mail clients
@section Other mail clients

Under the hood, @t{mu4e} is fully search-based, similar to programs like
@t{notmuch}@footnote{@url{http://notmuchmail.org}},
@t{md}@footnote{@url{https://github.com/nicferrier/md}} and
@t{sup}@footnote{@url{http://sup.rubyforge.org/}}. However, @t{mu4e}'s
user-interface is quite different from those programs.

@t{mu4e}'s mail handling (deleting, moving etc.) is inspired by
@emph{Wanderlust}@footnote{@url{http://www.gohome.org/wl/}} (another
emacs-based e-mail client), @t{mutt}@footnote{@url{http://www.mutt.org/}} and
@t{dired}, while it also takes some cues from @emph{Gmail}.

@t{mu4e} tries to keep all the 'state' in your maildirs, so you can easily
switch between clients, synchronize over @abbr{IMAP}, backup with @t{rsync}
and so on. If you delete the database, you won't lose any information.

@node What mu4e does not do
@section What mu4e does not do

@t{mu} and @t{mu4e} do @emph{not} deal with getting your e-mail messages from
a mail server. That task is delegated to other tools, such as
@t{offlineimap}@footnote{@url{http://offlineimap.org/}},
@t{isync}@footnote{@url{http://isync.sourceforge.net/}} or
@t{fetchmail}@footnote{@url{http://www.fetchmail.info/}}. As long as the
messages end up in a Maildir, @t{mu4e} and @t{mu} are happy to deal with them.

@t{mu4e} also does @emph{not} implement sending of messages; instead, it
depends on @inforef{Top,smtpmail,smtpmail}, which is part of @t{emacs}. In
addition, @t{mu4e} piggybacks on Gnus' message editor; @inforef{Top,Gnus
message editor,message}.

Thus, many of the things an e-mail client traditionally needs to do, are
delegated to other tools. This leaves @t{mu4e} to concentrate on what it does
best: quickly finding the mails you are looking for, and handle them as
efficiently as possible.

@node Getting started
@chapter Getting started

In this chapter, we go through the installation of @t{mu4e} and show how you
can set it up. After we have succeeded in @ref{Getting mail}, and
@ref{Indexing your messages}, we discuss @ref{Basic configuration}.

After these steps, @t{mu4e} should be ready to go.

@menu
* Installation::
* Getting mail::
* Indexing your messages::
* Basic configuration::
* Folders::
* Sending mail::

@end menu

@node Installation
@section Installation

@t{mu4e} is part of @t{mu} - by installing the latter, the former will be
installed as well. Note, some distributions provide packed versions of
@t{mu}/@t{mu4e}; if you can use those, there's no need to compile anything
yourself. However, if there are no packages for your distribution, or if you
want to use the latest development versions, you can follow the steps below.

First, you need make sure you have the necessary dependencies. On a Debian or
Ubuntu system, you can get these with:

@example
sudo apt-get install libgmime-2.4-dev libxapian-dev
# emacs if you don't have it yet, mu4e works with GNU-Emacs 23 and 24
# emacs 24 works better; it may be available as 'emacs-snapshot'
sudo apt-get install emacs23
# optional
sudo apt-get install guile-2.0-dev html2text xdg-utils
# optional: only needed for msg2pdf
sudo apt-get install libwebkit-dev
@end example

Using a release-tarball (as avaiable from
GoogleCode@footnote{@url{http://code.google.com/p/mu0/downloads/list}},
Installation follows the normal sequence:

@example
$ tar xvfz mu-<version>.tar.gz  # use the specific version
$ cd mu-<version>
$./configure && make
$ sudo make install
@end example

Alternatively, if you build from the git repository, or use a tarball like the
ones that @t{github} produces, the instructions are slightly different (and
require you to have @t{autotools} installed):

@example
# get from git, or from a github tarball
$ cd mu-<version>
$ autoreconf -i && ./configure && make
$ sudo make install
@end example

After this, @t{mu} and @t{mu4e} should be installed @footnote{there's a hard
dependency between versions of @t{mu4e} and @t{mu} - you cannot combine
different versions}, and be available from the command line and emacs
(respectively).

You may need to restart @t{emacs}.

@subsection mu4e and emacs customization

There is @emph{experimental} support for using the @t{emacs} customization
system in @t{mu4e}, but for now, we recommend setting the values
manually. Please refer to @xref{Example configuration} for a couple of
examples of this.

@node Getting mail
@section Getting mail

In order for @t{mu} (and, by extension, @t{mu4e}) to work, you need to have
your e-mail messages stored in a Maildir. If you are already using Maildirs,
you are lucky; otherwise, you will need to get your mail there in some way.

If you are using some external @abbr{IMAP} or @abbr{POP} server, you can use
tools like @t{getmail}, @t{fetchmail} @t{offlineimap} or @t{isync} to download
your message into a maildir-directory (@file{~/Maildir}, usually). If you are
using a local mail-server (such as @emph{Postfix} or @t{qmail}), you can teach
them to deliver into a maildir as well, maybe in combination with
@t{procmail}. A bit of googling should be able to provide you with the
details; also there is full example of setting @t{mu4e} up with
@t{offlineimap} and Gmail; @pxref{Gmail configuration}.

You can do all of the mail retrieval @emph{outside} of @t{emacs}/@t{mu4e}, but
you can also do it from within @t{mu4e}. For that, set the variable
@code{mu4e-get-mail-command} to the program or shell command you want to use
for retrieving mail. You can then retrieve your e-mail from the @ref{Main
view}.

You can also have this command run periodically in the background, by setting
the variable @code{mu4e-update-interval} to the number of seconds between
these updates. If set to @code{nil}, it will not update at all. If you make
changes to @code{mu4e-update-interval}, @code{mu4e} must be restarted before
the change will take effect.

@node Indexing your messages
@section Indexing your messages

After you have succeeded in @ref{Getting mail}, we need to @emph{index} the
messages. That is - we need to scan the Maildir and store the information
about the mails into a special database. We can do that from @code{mu4e} --
@ref{Main view}, but the first time, it is a good idea to run it from the
command line, as it is easier to recognize potential problems.

Assuming that your Maildir is at @file{~/Maildir}, you should give the
following command:
@example
  $ mu index --maildir=~/Maildir
@end example

This should scan your @file{~/Maildir}@footnote{In most cases, you do not even
need to provide the @t{--maildir=~/Maildir}; see the @t{mu-index} man-page for
details} and fill the database, and give progress information while doing so.

The indexing process may take a few minutes the first time you do it (for
thousands of e-mails); afterwards it is much faster, since @t{mu} only has to
scan the differences. Indexing is discussed in more detail in the @t{mu-index}
man page.

After the indexing process has finished, you can quickly test if everything
worked, by trying some command line searches, for example

@example
  $ mu find hello
@end example

which should list all messages that match @t{hello}. For more examples of
searches @xref{Queries}, or check the @t{mu-find} and @t{mu-easy} man pages.

If all of this worked well, we are well on our way setting up @t{mu4e}; the
next step is to do some basic configuration.

@node Basic configuration
@section Basic configuration

The first thing we need to do before we can start using @t{mu4e} is to tell
@t{emacs} to load @t{mu4e}, and tell @t{mu4e} where it can find specific
maildir folders.

So, add to your @file{~/.emacs} (or equivalent) something like:

@example
(require 'mu4e)
@end example

@node Folders
@section Folders

The next step is to tell @t{mu4e} where it can find your Maildir, and some
special folders. So, for example:
@lisp
  (setq
    mu4e-maildir       "~/Maildir"   ;; top-level Maildir
    mu4e-sent-folder   "/sent"       ;; where do i keep sent mail?
    mu4e-drafts-folder "/drafts"     ;; where do i keep half-written mail?
    mu4e-trash-folder  "/trash")     ;; where do i move deleted mail?
@end lisp

@code{mu4e-maildir} takes an actual filesystem-path, the other folder names are
all relative to @code{mu4e-maildir}. The next step is telling @t{mu4e} how we
want to send mail.

@node Sending mail
@section Sending mail

@t{mu4e} re-uses Gnu's @inforef{Top,,message} for writing mail and inherits
the setup for @emph{sending} mail from that.

For sending mail using @abbr{SMTP}, @t{mu4e} uses
@inforef{Top,,smtpmail}. This package support many different ways to send
mail, please refer to its documentation for the details.

Here, we only provide some simple examples - for more, @ref{Example
configuration}.

A very minimal setup could look something like:

@lisp
;; tell message-mode how to send mail
(setq message-send-mail-function 'smtpmail-send-it)
;; if our mail server lives at smtp.example.org; if you have a local
;; mail-server, simply use 'localhost' here.
(setq smtpmail-smtp-server "smtp.example.org")
@end lisp

Since @t{mu4e} uses the same @t{message mode} and @t{smtpmail} that Gnus uses,
many settings for those will also apply to @t{mu4e}.

By default, @t{mu4e} puts a copy of any messages you sent in the folder you
set for @code{mu4e-sent-folder}. In some case, this may not be what you want -
for example, when using Gmail+@abbr{IMAP} (but @emph{not} with
Gmail+@abbr{POP3}), this interferes with Gmail's handling of the sent messages
folder, and you may end up with duplicate messages.

Since @t{mu4e} 0.9.8.3, there is the variable
@code{mu4e-sent-messages-behavior} for, which takes a symbol. The default is
@code{'sent} which, as mentioned, causes the message to be copied to your
sent-messages folder. Other possible values are @code{'trash} (so the sent
message is copied to the trash-folder (@code{mu4e-trash-folder}), and
@code{'delete} to simply discard the message altogether.

For Gmail-IMAP you could add the following to your settings:

@verbatim
;; don't save messages to Sent Messages, Gmail/IMAP will take care of this
(setq mu4e-sent-messages-behavior 'trash)
@end verbatim

And that's it! We should be ready to go now.

@node Running mu4e
@chapter Running mu4e

After the following the steps in @ref{Getting started}, we should now have a
working @t{mu4e} setup. In this chapter, we'll give a tour of the @t{mu4e}
program, and show its use.

@t{mu4e} consists of a number of views; the diagram shows how they relate to
each other, and the default key-bindings to get from one view to the next. In
the next sections we will describe what these keys actually @emph{do}.

@menu
* Main view:: This is where we start
* Headers view:: Lists of message headers
* Message view:: Viewing specific messages
* Editor view:: Creating / editing messages
@end menu


@example
----------------------------------------------------------------------------

        [C]     +--------+   [RFCE]
      --------> | editor | <--------
     /          +--------+          \
    /         [RFCE]^                \
   /                |                 \
+-------+ [sjbB]+---------+  [RET] +---------+
| main  | <---> | headers | <----> | message |
+-------+  [q]  +---------+ [qbBjs]+---------+
                  [sjbB]                ^
                                    [.] | [q]
                                        V
                                      +-----+
                                      | raw |
                                      +-----+

Default bindings
----------------
R: Reply      s: search            .: raw view (toggle)
F: Forward    j: jump-to-maildir   q: quit
C: Compose    b: bookmark-search
E: Edit       B: edit bookmark-search

----------------------------------------------------------------------------
@end example

@node Main view
@section Main view

After you have installed @t{mu4e} (@pxref{Getting started}), you can start it
with @code{M-x mu4e}. @t{mu4e} wil do some checks to ensure everything is set
up correctly, and then show you the @t{mu4e} main view.

This looks something like the following:

@verbatim
----------------------------------------------------------------------------
* mu4e - mu for emacs version x.x

  Basics

	* [j]ump to some maildir
	* enter a [s]earch query
	* [C]ompose a new message

  Bookmarks

	* [bu] Unread messages
	* [bt] Today's messages
	* [bw] Last 7 days
	* [bp] Messages with images
  Misc

	* [U]pdate email & database
	* toggle [m]ail sending mode (direct)
	* [f]lush queued mail

        * [A]bout mu4e
        * [H]elp
	* [q]uit mu4e
----------------------------------------------------------------------------
@end verbatim

Below, we assume the default key bindings here. If you've changed those, well,
@emph{mutatis mutandis}.

@subsection Basic actions

First, the @emph{Basics}:
@itemize
@item @t{[j]ump to some maildir} means that after pressing @key{j},
@t{mu4e} will ask you for a maildir to visit. These are the maildirs you set
in @ref{Basic configuration}, or, if you choose @key{o} for @emph{other}, all
maildirs.
@item @t{enter a [s]earch query} means that after pressing @key{s} you will
be asked for a search query, and after entering one, the results will be
shown. @xref{Searching}.
@item @t{[C]ompose a new message} means that after pressing @key{C}, you
will be thrown in a message-editing buffer, where you can compose a new message.
@end itemize

@subsection Bookmarks

Next come @emph{Bookmarks}. These are set with the variable
@code{mu4e-bookmarks}; what you see in the above example are the
@emph{default} bookmarks - you can add your own and/or replace the default
ones; @xref{Bookmarks}. In short, you can view the list of messages matching a
certain bookmark by pressing @key{b} followed by the shortcut for this
bookmark. If you'd like to edit the bookmarked query first, use @key{B}.

@subsection Miscellaneous

Finally, there are some @emph{Misc} (miscellaneous) actions:
@itemize
@item @t{[U]pdate email & database} will execute whatever is in
the variable @code{mu4e-get-mail-command}, and afterwards update the @t{mu}
database; @pxref{Indexing your messages}. See @ref{Getting mail} for details.
@item @t{toggle [m]ail sending mode (direct)} will toggle between sending
mail directly, and queuing it first (for example, when you are offline), and
@t{[f]lush queued mail} will flush any queued mail. This item is visible only
if you have actually set up mail-queuing. @ref{Queuing mail}.
@item @t{[A]bout mu4e} will give some general information about @t{mu4e}.
@item @t{[H]elp} will show help information for this view.
@item Finally, @t{[q]uit mu4e} will quit @t{mu4e}.
@end itemize

@node Headers view
@section Headers view

The headers view shows the results of a search query. There is a line for each
matching message, showing information about it. It looks something like the
following:

@verbatim
----------------------------------------------------------------------------------
  Date              Flags  From/To             Subject
  2011-12-16 18:38  uN     To Edmund Dantès    + Re: Extension security?
  2011-12-16 21:44  uN     Abbé Busoni             + Re: Extension security?
  2011-12-17 03:14  uN     Pierre Morrel           + Re: Extension security?
  2011-12-17 04:04  uN     Jacopo                    + Re: Extension security?
  2011-12-17 14:36  uN     Mercédès                    + Re: Extension security?
  2011-12-18 06:05  uN     Beachamp                      \ Re: Extension security?
  2011-12-16 18:23  uN     Albert de Moncerf   + Re: [O] A presentation tool
  2011-12-17 01:53  usaN   Gaspard Caderousse    \ Re: [O] A presentation tool
  2011-12-16 16:31  uN     Baron Danglars      | [O] imaxima?
End of search results
----------------------------------------------------------------------------------
@end verbatim

@subsection Some notes

Some notes to explain what you see in the example:

@itemize
@item The fields shown in the headers view can be influenced by customizing
the variable @code{mu4e-headers-fields}
@item Instead of showing the @t{From:} and @t{To:} fields separately, you
can use From/To (@t{:from-or-to} in @code{mu4e-headers-fields} as a more
compact way to convey the most important information: it shows @t{From:}
@emph{except} when the e-mail was sent by the user (i.e., you) - in that case
it shows @t{To:} (prefixed by @t{To}@footnote{You can customize this by
changing the variable @code{mu4e-headers-from-or-to-prefix} (a cons cell)}, as
in the example above). To determine whether a message was sent by you,
@t{mu4e} uses the variable @code{mu4e-user-mail-address-regexp}, which should
be a regular expression matching all the e-mail addresses that you use.
@item The letters in the 'Flags' field correspond to the following: D=draft,
F=flagged, N=new, P=passed (i.e.., forwarded), R=replied, S=seen, T=trashed,
a=has-attachment, x=encrypted, s=signed, u=unread.
@item You can change the date format by customizing the variable
@t{mu4e-headers-date-format}
@item The subject field displays the discussion threads according to the @emph{JWZ mail
threading algorithm}@footnote{@url{http://www.jwz.org/doc/threading.html}}.
@end itemize

@subsection Keybindings

Using the default key bindings, you can do various things with these messages;
these actions are also listed in the @t{Headers} menu in the Emacs menu bar.

@verbatim
key          description
===========================================================
n,p          go to next, previous message
y            select the message view (if it's visible)
RET          open the message at point in the message view

searching
---------
s            search
S            edit last query
/            narrow the search
b            search bookmark
B            edit bookmark before search
j            jump to maildir
M-left       previous query
M-right      next query

O            change sort order
P            toggle threading
Q            toggle full-search


marking
-------
d            mark for moving to the trash folder
DEL,D        mark for immediate deletion
m            mark for moving to another maildir folder
+,-          mark for flagging/unflagging
o,r          mark message as unread, read

u            unmark message at point
U            unmark *all* messages

%            mark based on a regular expression
T,t          mark whole thread, subthread

*            deferred mark (decide what to mark for later)
#            resolve deferred marks

x            execute actions for the marked messages

composition
-----------
R,F,C        reply/forward/compose
E            edit (only allowed for draft messages)


misc
----
a            execute some custom action on a header
|            pipe message through shell command
C-+,C--      increase / decrease the number of headers shown
H            get help
q,z          leave the headers buffer
@end verbatim

@subsection Marking messages
@anchor{Marking messages}

The mark/unmark commands support the current @emph{region} (i.e., selection)
-- so, for example, if you the select ('mark' in emacs lingo) a number of
message (like you would select text in a buffer) and then press @key{DEL}, all
selected message will be marked for deletion.

The two-step mark-execute sequence is similar to what @t{dired} and som other
emacs-based programs do. This way, @t{mu4e} tries to be as quick as possible
while avoiding accidents.

You can mark all messages that match a certain pattern with @key{%}. In
addition, you can mark all messages in the current thread (@key{T}) or
sub-thread (@key{t}).

When you try to do a new search, or refresh the headers buffer while you still
have marked messages, normally you will be asked what to do with those marks
-- whether to @emph{apply} them before leaving, or @emph{ignore} them. This
behavior can be influenced with the variable
@code{mu4e-headers-leave-behavior} -- see its documentation.

For more information about marking, @xref{Marking}.

@subsection Sort order and threading
@anchor{Sort order and threading}

By default, @t{mu4e} sorts messages by date, in descending order: the most
recent messages are shown at the top. In addition, the messages are
@emph{threaded}, i.e., shown in the context of a message thread; this also
affects the sort order.

You can change the sort order with @t{M-x mu4e-headers-change-sorting} or
@key{O}, and you can toggle threading on/off using @t{M-x
mu4e-headers-toggle-threading} or @key{P}. For both of these functions, unless
you provide a prefix argument (@key{C-u}), the current search is updated
immediately using the new parameters. You can toggle full-search
(@ref{Searching}) using @t{M-x mu4e-headers-toggle-full-search} or @key{Q}.

If you want to change the defaults for these settings, you can use the
variables @code{mu4e-headers-sortfield} and @code{mu4e-headers-show-threads}.

Note that you can see the current settings in the emacs modeline; it shows the
current query, followed by the shortcut character for sortfield (the same
character you'd use in @code{mu4e-headers-change-sorting}. The next character
is either @t{a} (for ascending, @emph{A->Z} order), or @t{d} (for descending,
@emph{Z->A} order). If threading is enabled, the next character is a @t{T}, and
finally, if we're doing an unlimited, full search, the last character is an
@t{F}.

To illustrate this, suppose our query is @t{subject:foo maildir:/bar}, we're
sorting by subject in ascending order with threads enabled, and it's a full
search. The corresponding mode-line string then is: @t{subject:foo
maildir:/bar(saTF)}.

@subsection Actions

@code{mu4e-headers-action} (@key{a}) lets you pick custom actions to perform
on the message at point. You can specify these actions using the variable
@code{mu4e-headers-actions}. Refer to @ref{Actions} for details.

@t{mu4e} defines some default actions - one is @t{capture} - @key{a c} will
'capture' the current message. Next, when you're editing some message, you can
include the previously captured message as an attachment, using
@code{mu4e-compose-attach-captured-message}.

The file @file{mu4e-actions.el} in the @t{mu4e} source distribution contains a
number of example actions.

@subsection Split view

Using the @emph{Split view}, we can see the @ref{Headers view} and the
@ref{Message view} next to each other, with the message that is selected in
the former, visible in the latter.

You can influence the way the splitting is done by customizing the variable
@code{mu4e-split-view} in your configuration to one of 3 values:
@itemize
@item @t{horizontal} (this is the default): display the message view below the
header view
@item @t{vertical}: display the message view on the
right side of the header view
@item anything else: don't do any splitting
@end itemize

When splitting horizontally, you can determine the number of visible header
lines with with the variable @t{mu4e-headers-visible-lines} (default value:
8). When split vertically you can use @t{mu4e-headers-visible-columns}
(default value: 30) to set the number of visible columns.

When the message view window is selected, you cannot use the arrow keys for
moving to the next / previous message (like you can in the headers view),
since those are already assigned to cursor movement in the message.  However,
instead can use the @key{p} (or @key{M-up}) and @key{n} (or @key{M-down}) keys
for moving to the previous and the next message, respectively. These keys also
work in the headers view.

You can change the selected window from the headers-view to the message-view
and vice-versa with @code{mu4e-select-other-view}, bound to @key{y}.

@node Message view
@section Message view

After selecting a message in the @ref{Headers view}, it will be shown in the
message view, for example:

@verbatim
----------------------------------------------------------------------------
From: info@galatians.net
To: "Paul" paul@hotmail.com
Subject: Re: some thoughts
Flags: (seen attach)
Date: Mon 19 Jan 2004 09:39:42 AM EET
Maildir: /inbox
Attachments(2): [1]DSCN4961.JPG(1.3M), [2]DSCN4962.JPG(1.4M)

Hi Paul,

How are you? Sorry we didn't get back to you sooner and sorry for the
top-quoting. We're still debating your last message; anyway, here are some
recent pics. And here's a link: http://example.com[1]

All the best!

On Sun 21 Dec 2003 09:06:34 PM EET, Paul wrote:

[....]
----------------------------------------------------------------------------
@end verbatim

Some notes:
@itemize
@item You can determine which header fields are shown by setting the
variable @code{mu4e-view-fields}.
@item You can customize the date format by setting the variable
@code{mu4e-date-format-long}, using the same format that
@code{format-time-string} uses.
@item If you only want to see the name and not the e-mail address of the
contacts in address fields, you can set @option{mu4e-view-show-addresses} to
@t{nil}. This will hide the addresses for contacts that also have a name. The
e-mail address is still available as a tool-tip.
@item The body text can be line-wrapped (toggle between wrapped/not-wrapped with
@key{w}) and/or cited parts can be hidden (toggle between hidden/not-hidden
with @key{h}. If you want to do this by default when viewing messages, you can
set, respectively, @code{mu4e-view-wrap-lines} and @code{mu4e-view-hide-cited}
to @code{t}. @footnote{If you have installed the @t{filladapt} package
(@url{http://www.wonderworks.com/download/filladapt.el}), @t{mu4e} will use it
for line-wrapping, as it generally does a better job than the default
mechanism emacs provides.}
@item For search-related operations, see @ref{Searching}.
@end itemize

@subsection Keybindings

You can find most things you can do with this message in the @emph{View} menu,
or by using the keyboard; the default bindings are:

@verbatim
key          description
==============================================================
n,p          go to next, previous message
y            select the headers view (if it's visible)

searching
---------
s            search
e            edit last query
/            narrow the search
b            search bookmark
B            edit bookmark before search
j            jump to maildir

M-left       previous query
M-right      next query

marking
-------
d            mark for moving to the trash folder
DEL,D        mark for immediate deletion
m            mark for moving to another maildir folder
+,-          mark for flagging/unflagging
o,r          mark message as unread, read

u            unmark message at point
U            unmark *all* messages

%            mark based on a regular expression
T,t          mark whole thread, subthread

SPC          deferred mark (decide what to mark for later)
*            resolve deferred marks

x            execute actions for the marked messages

composition
-----------
R,F,C        reply/forward/compose
E            edit (only allowed for draft messages)

actions
-------
g            go to (visit) numbered URL (using `browse-url')
             (or: <mouse-2> or RET with point on url)
e            extract (save) attachment (asks for number)
             (or: <mouse-2> or RET with point on attachment)
             C-u e will extract multiple attachments
o            open attachment (asks for number)
             (or: <S-mouse-2> or S-RET with point on attachment)

a            execute some custom action on the message
A            execute some custom action on an attachment

misc
----
w            toggle line wrapping
h            toggle showing cited parts

.            show the raw message view. 'q' takes you back.
C-+,C--      increase / decrease the number of headers shown
H            get help
q,z          leave the message view
@end verbatim

For the marking commands, please refer to @ref{Marking messages}.

@subsection Opening and saving attachments

By default, when opening attachments, @t{mu4e} uses the the
@t{xdg-open}-program @footnote{@url{http://portland.freedesktop.org/wiki/}} or
(on MacOS) the @t{open} program. If you want to use another program, you can
specify this by setting the @t{MU_PLAY_PROGRAM} environment variable.

When extracting (saving) attachments (with @key{e}), the default directory for
saving them is your home directory (@file{~/}); you can change this using the
variable @code{mu4e-attachment-dir}, for example:

@lisp
(setq mu4e-attachment-dir (file-name-expand "~/Downloads"))
@end lisp

If you want to extract multiple attachments at once, you can do so by
prefixing the extracting command by @key{C-u}; so @key{C-u e} will ask you for
a range of attachments to extract (for example, 1 3-6 8). Range @t{a} is a
shortcut for @emph{all} attachments.

@subsection Viewing images inline
@anchor{Viewing images inline}

It is possible to show images inline in the message view buffer if you run
emacs in GUI-mode. You can enable this by setting the variable
@code{mu4e-view-show-images} to @t{t}.

Since emacs does not always handle images correctly, this is not enabled by
default. Note, if you are using a (pre-) release of emacs 24 and build it
yourself, you probable want to build it with @emph{Imagemagick} support -- in
that case, also make sure you call @code{imagemagick-register-types} in your
configuration, so it is used for images.

@lisp
;; enable inline images
(setq mu4e-view-show-images t)
;; use imagemagick, if available
(when (fboundp 'imagemagick-register-types)
   (imagemagick-register-types))
@end lisp

@subsection Actions

@code{mu4e-view-action} (@key{a}) lets you pick some custom action to perform
on the current message. You can specify these actions using the variable
@code{mu4e-view-actions}.

Similarly, there is @code{mu4e-view-attachment-action} (@key{A}) for actions
on attachments, which you can specify with
@code{mu4e-view-attachment-actions}.

By default, @t{mu4e} already offers a few useful actions for attachments:

@itemize
@item @t{open-with} (@key{w}): open the attachment with some arbitrary
program. For example, suppose you have received a message with a picture
attachment; then, @t{A w 1 RET gimp RET} will open that attachment in The
Gimp.
@item @t{pipe} (@key{|}: process the attachment with some Unix shell-pipe and
see the results. Suppose you receive a patch file, and would like to get an
overview of the changes, using the @t{diffstat} program. You can use something
like: @t{A | 1 RET diffstat -b RET}.
@item @t{emacs} (@key{e}): open the attachment in your running @t{emacs}. For
example, if you receive some text file you'd like to open in @t{emacs}:
@t{A e 1 RET}.
@end itemize

These actions all work on a @emph{temporary copy} of the attachment.

For more information on setting up actions and how to define them, see
@ref{Actions}.

@subsection Displaying rich-text messages

For displaying messages, @t{mu4e} normally prefers the plain-text version for
messages consisting of both a plain-text and an html (rich-text) version of
its body-text.

If there is only an html-version, or if the plain-text version is too short in
comparison with the html part, @t{mu4e} tries to convert the html into
plain-text for display. The default way to do that is to use the Emacs
built-in @code{html2text} function, but if you set the variable
@code{mu4e-html2text-command} to some external program, that program will be
used. This program is expected to take html from standard input and write
plain text in @t{utf-8} encoding on standard output.

An obvious choice for this is the program that is actually @emph{called}
@t{html2text}@footnote{@url{http://www.mbayer.de/html2text/}}, which you could
set up with something like the following in your initialization files:

@lisp
(setq mu4e-html2text-command "html2text -utf8 -width 72")
@end lisp

An alternative to this is to use the Python @t{python-html2text} package;
after installing that, you can tell @t{mu4e} to use it with something like:

@lisp
(setq mu4e-html2text-command "html2markdown | grep -v '&nbsp_place_holder;'")
@end lisp

As mentioned, by default @t{mu4e} prefers the text-version of an e-mail
message over the html version. You can change this by setting
@code{mu4e-view-prefer-html} to @t{t}.

@node Editor view
@section Editor view

For its editor, @t{mu4e} re-uses Gnu's @t{message-mode}. For example, when
replying to a message, the editor view looks something like the following:

@verbatim
----------------------------------------------------------------------------
From: Rupert the Monkey <rupert@example.com>
Reply-To: rupert@example.com
To: Wally the Walrus <wally@example.com>
In-reply-to: <201201160918.47080.ssdfz@example.com>
Subject: Re: Eau-qui d'eau qui?
--text follows this line--

On Mon 16 Jan 2012 10:18:47 AM EET, Wally the Walrus wrote:

 > Hi Rupert,
 >
 > Dude - how are things?
 >
 > Later -- wally.
----------------------------------------------------------------------------
@end verbatim

Since @t{mu4e} uses @t{gnu}'s message editor, for documentation
@inforef{Message}. Also, @pxref{Sending mail}. There are many key-bindings
available, here are some of the essential ones (you can use the menu to find
more):

@subsection Some useful keybindings

@verbatim
key          description
---          -----------
C-c C-c      send message
C-c C-d      save to drafts and leave
C-c C-k      kill the message
C-c C-a      attach a file (pro-tip: drag & drop works as well)
@end verbatim

If you want use @t{mu4e} as the default program for sending mail, please see
@ref{Setting the default emacs mail program}. With respect to sending mail,
other interesting topics: @ref{Citations with mu-cite} and @ref{Maintaining an
address-book with org-contacts}.

Normally, @t{mu4e} will @emph{bury} the message buffer after sending; if you
want to kill the buffer instead, add something like the following to your
configuration:

@lisp
(setq message-kill-buffer-on-exit t)
@end lisp

@subsection Address autocompletion
@anchor{Address autocompletion}

Since @t{mu}/@t{mu4e} version 0.9.8.5, there is support for autocompleting
addresses using @key{TAB} when composing e-mail messages. As the source for
the addresses to complete, @t{mu4e} uses the e-mail addresses in its database
-- addresses you sent messages to or received messages from. @emph{Note:}
auto-completion should work with emacs versions 23.2 and later.

Address auto-completion is enabled by default, using the variable
@t{mu4e-compose-complete-addresses}.

@subsection Limiting the number of addresses for autocompletion

If you have a lot of mail, especially from mailing lists and the like, there
will be @emph{many} e-mail adresses, most of which are unlikely to be useful
when auto-completing. For example, consider e-mail addresses in five year old
mailing lists posts.

So, @t{mu4e} attempts to limit the number of e-mail addresses in the
completion pool by filter the ones that are most likely to be relevant. The
following variables are available to tune this:

@itemize
@item @code{mu4e-compose-complete-only-personal} - when set to @t{t},
only consider addresses that were seen in @emph{personal} messages -- that is,
messages in which one of my e-mail addresses was seen in one of the address
fields. This is to exclude mailing list posts. You can define what is
considered 'my e-mail address' using @code{mu4e-my-email-addresses}, a list of
e-mail address (defaults to @t{(user-mail-address)}), and when indexing from
the command line, the @t{--my-address} parameter for @t{mu index}.
@item @code{mu4e-compose-complete-only-after} - only consider e-mail
addresses seen after some date. Parameter is a string, parseable by
@code{org-parse-time-string}. This excludes very old e-mail addresses. The
default is @t{"2010-01-01"}, i.e., only consider e-mail addresses used since
the start of 2010.
@item @code{mu4e-compose-complete-ignore-address-regexp} - a regular expression to
filter out other 'junk' e-mail addresses; defaults to @t{noreply}.
@end itemize


@subsection Queuing mail
@anchor{Queuing mail}

If you cannot send mail directly, for example because you are currently
offline, you can @emph{queue} the mail, and send it when you have restored
your internet connection. You can control this from the @t{mu4e} @ref{Main
view}.

To allow for queuing, you need to tell @t{smtpmail} where you want to do
this. For example:

@lisp
(setq smtpmail-queue-mail  nil  ;; start in non-queuing mode
      smtpmail-queue-dir   "~/Maildir/queue/cur")
@end lisp

For convenience, we locate the queue directory somewhere in our normal
maildir. If you want to use queued mail, you should create this directory
before starting @t{mu4e}. The @command{mu mkdir} command may be useful here,
so for example:

@verbatim
$ mu mkdir ~/Maildir/queue
$ touch ~/Maildir/queue/.noindex
@end verbatim

The file created by the @command{touch} command tells @t{mu} to ignore this
directory for indexing, which makes sense since it contains @t{smtpmail}
meta-data rather than 'normal' messages; see the @t{mu-mkdir} and @t{mu-index}
man pages for details.

@emph{Warning}: when you switch on queued-mode, your messages will not reach
their destination until you switch it off again; so, be careful not to do this
accidentally.


@node Searching
@chapter Searching

@t{mu4e} is fully search-based; this means that all the lists of messages you
see, are the result of some query. Even if you 'jump to a folder', in fact you
are executing a search query for messages that happen to have the property of
being in a certain folder.

By default, queries return up to @code{mu4e-search-results-limit} (default:
500) results. That's usually more than enough, and helps performance quite a
bit. Sometimes, you may want to show @emph{all} results; you can enable this
with @t{M-x mu4e-headers-toggle-full-search}, or by customizing the variable
@code{mu4e-headers-full-search}. This applies to all search commands.

You can also influence the sort order and whether threads are shown or not;
see @ref{Sort order and threading}.

@menu
* Queries::
* Bookmarks::
* Maildir searches::
* Other search functionality::
@end menu

@node Queries
@section Queries

The queries you can execute are the same ones that @code{mu find}
understands. Please refer to the @code{mu-find} and @code{mu-easy} man pages
for details and more examples.

@verbatim
# get all messages about bananas
bananas

# get all messages about bananas from john with an attachment
from:john flag:attach bananas

# get all messages with subject wombat in June 2009
subject:wombat date:20090601..20090630

# get all messages with PDF attachments in the /projects folder
maildir:/projects mime:application/pdf

# get all important messages which are signed:
flag:signed prio:high

# get all messages from Jim without an attachment:
from:jim AND NOT flag:attach

# get all unread messages where the subject mentions Ångström:
subject:angstrom flag:unread

# get all unread messages between Mar-2002 and Aug-2003 about some bird
date:20020301..20030831 nightingale flag:unread

# get today's messages
date:today..now

# get all messages we got in the last two weeks regarding emacs
date:2w..now emacs

# get mails with a subject soccer, Socrates, society...
# note: the '*' wildcard can only appear as the rightmost character in the term
subject:soc*

# get all mails with attachment with filenames starting with 'pic'
# note: the '*' wildcard can only appear as the rightmost character in the term
file:pic*

# get all messages with PDF attachments:
mime:application/pdf

# get all messages with image attachments:
# note: the '*' wildcard can only appear as the rightmost character in the term
mime:image/*
@end verbatim

@node Bookmarks
@section Bookmarks

If you have queries that you use often, you may want to store them as
@emph{bookmarks}. These bookmarks then show up in the main view, and you can
invoke them in other places as well. Bookmark searches are available in the
main view @ref{Main view}, header view @xref{Headers view}, and message view
@xref{Message view}, using (by default) the key @key{b}
(@code{mu4e-search-bookmark}).

@subsection Setting up bookmarks

@code{mu4e} provides some default bookmarks, which you can override. The
definition of the default bookmarks is instructive here:

@lisp
(defvar mu4e-bookmarks
  '( ("flag:unread AND NOT flag:trashed" "Unread messages"      ?u)
     ("date:today..now"                  "Today's messages"     ?t)
     ("date:7d..now"                     "Last 7 days"          ?w)
     ("mime:image/*"                     "Messages with images" ?p))
  "A list of pre-defined queries; these will show up in the main
screen. Each of the list elements is a three-element list of the
form (QUERY DESCRIPTION KEY), where QUERY is a string with a mu
query, DESCRIPTION is a short description of the query (this will
show up in the UI), and KEY is a shortcut key for the query.")
@end lisp

You can replaces these, or add your own items, by putting in your
configuration (@file{~/.emacs}) something like:
@lisp
(add-to-list 'mu4e-bookmarks
  '("size:5M..500M"       "Big messages"     ?b))
@end lisp

This prepends your bookmark to the list, and assigns the key @key{b} to it. If
you want to @emph{append} your bookmark, you can use @code{t} as the third
argument to @code{add-to-list}.

In the various @t{mu4e} views, pressing @key{b} will list all the bookmarks
defined in the echo area, with the shortcut key highlighted. So, to invoke the
bookmark we just defined (to get the list of "Big Messages"), all you need to
type is @key{bb}.

@subsection Editing bookmarks before searching

There is also @code{mu4e-headers-search-bookmark-edit-first} (key @key{B}),
which lets you edit the search query with some bookmark already filled
in. This can be useful if you have many similar queries, but need to change
some parameter. For example, you could have a bookmark @t{"NOT maildir:/Trash
AND"}@footnote{Not a valid search query by itself} and add whatever you want
to search for to that. Or, to do a query limited to the messages of today, all
you need to type is @key{Bt} (using the @t{Today's messages}-bookmark, see
above).

@node Maildir searches
@section Maildir searches

Maildir searches are quite similar to bookmark searches (see @ref{Bookmarks}),
with the difference being that the target is always a maildir -- maildir
queries provide a 'traditional' folder-like interface to a search-based e-mail
client. By default, maildir searches are available in the @ref{Main view},
@ref{Headers view}, and @ref{Message view}, with the key @key{j}
(@code{mu4e-jump-to-maildir}).

@subsection Setting up maildir shortcuts

You can do Maildir searches manually (e.g. with a query like
@code{maildir:/myfolder}) but since it is so common, @t{mu4e} offers a quicker
way to do this.

To enable this, you need to set the variable @t{mu4e-maildir-shortcuts} to
list of maildirs you'd like to have quick access to, for example:

@lisp
   (setq mu4e-maildir-shortcuts
    '( ("/inbox"     . ?i)
       ("/archive"   . ?a)
       ("/lists"     . ?l)
       ("/work"      . ?w)
       ("/sent"      . ?s))
@end lisp

This would set @key{i} as a shortcut for the @t{/inbox} folder; so effectively
a query @t{maildir:/inbox}. There is a special shortcut @key{o} for
@emph{other} (so don't use that one for your own shortcuts!), which allows you
to choose from @emph{all} maildirs. There is support for autocompletion; note
that the list of maildirs is determined when @t{mu4e} starts; if there are
changes in the maildirs while @t{mu4e} is running, you need to restart
@t{mu4e}.

Each of the folder names is relative to your top-level maildir directory; so if
you keep your mail in @file{~/Maildir}, @file{/inbox} would refer to
@file{~/Maildir/inbox}.

Having these shortcuts allows you to jump around your folder very quickly -
for example, getting to the @t{/lists} folder only requires you to type
@key{jl}.

The very same shortcuts are used by the @code{mu4e-mark-for-move} (default
shortcut @key{m}); so, for example, if you want to move a message the
@t{/archive} folder, you can do so by typing @key{ma}.

@node Other search functionality
@section Other search functionality

@subsection Navigating through search queries
You can navigate through previous/next queries using
@code{mu4e-headers-query-prev} and @code{mu4e-headers-query-next}, which are
bound to @key{M-left} and @key{M-right}, just like the way you can navigate to
previous and next pages in many webbrowsers.

The functions try to be smart as to not record duplicate queries. Also, the
number of queries remembered has a fixed limit, so long-running @t{mu4e} won't
use too much memory.

If you want to forget previous/next queries, you can use
@code{mu4e-headers-forget-queries}.

@subsection Narrowing search results

Sometimes, it is useful to narrow existing search results, i.e., add some
clauses to the current query to match fewer messages.

As an example of this, suppose you're looking at the some mailing list,
perhaps by jumping to a maildir (@code{mu4e-headers-jump-to-maildir},
@key{j}) or because you followed some bookmark
(@code{mu4e-headers-search-bookmark}, @key{b}). Now, of the messages in that
search, you want to narrow things down to only those messages that have
attachments.

Now, @code{mu4e-headers-search-narrow} (@key{/}) comes in handy. That function
asks for an additional search pattern, which will be appended to the current
search query, in effect getting you the subset of the currently shown headers
that also match this extra search pattern.

Technically, narrowing the results of query @t{x} with expression @t{y}
implies doing a search @t{(x) AND y}.

Note, messages that were not in your in your original search results because
of @code{mu4e-search-results-limit}, may still show up in the narrowed query.

@node Marking
@chapter Marking

The common way in @t{mu4e} to do things with messages is a two-step process -
first you @emph{mark} them for a certain action, then you @emph{execute}
(@key{x})the marks. This works in a way somewhat similar to @t{dired}.

Marking can happen in both the @ref{Headers view} and the @ref{Message view}.

@menu
* Selecting messages for marking::
* What to mark for::
* Executing the marks::
* Leaving the headers buffer::
* Custom mark functions::
* Some marking examples::
@end menu

@node Selecting messages for marking
@section Selecting messages for marking

There are a couple of ways to select messages for marking:
@itemize
@item @emph{message at point}: you can put a mark on the message-at-point in
either the @ref{Headers view} or @ref{Message view}
@item @emph{region}: you can put a mark on all messages in the current region
(selection) in the @ref{Headers view}
@item @emph{Pattern}: you can put a mark on all messages in the @ref{Headers
view} matching a certain pattern with @code{mu4e-headers-mark-pattern}
(@key{%})
@item You can put a mark on all the messages in the thread/subthread at point
with @code{mu4e-headers-mark-thread} and @code{mu4e-headers-mark-subthread},
respectively
@end itemize

@node What to mark for
@section What to mark for

@t{mu4e} supports a number of different marks - i.e., different actions to
apply to messages:

@verbatim
| mark for     | keybinding  | description              |
|--------------+-------------+--------------------------|
| trash        | d           | move to the trash folder |
| delete       | D, <delete> | delete                   |
| move         | m           | move to some maildir     |
| flag         | +           | mark as 'flagged'        |
| unflag       | -           | remove 'flagged' mark    |
| read         | r           | mark as read             |
| unread       | o           | marks as unread          |
| deferred     | *           | mark now, decide later   |
| unmark       | u           | remove mark at point     |
| unmark all   | U           | remove all marks         |
@end verbatim

After marking a header for something, the left-most columns shows a character
to remind you what you marked it with. Next to that, @t{mu4e} displays the
name of the mark, on top of the beginning of the header line. This latter
display is informative, but if you often mark many (thousands) messages, this
may slow down things significantly@footnote{this uses an emacs feature called
@emph{overlays}, which are slow when used a lot in a buffer}. For this reason,
you can disable this by setting @code{mu4e-headers-show-target} to @code{nil}.

@t{deferred} is a special kind of mark; you can use it to mark some messages,
and then decide later what mark to use for them. At any time, you can set the
actual mark with @code{mu4e-mark-resolve-deferred-marks} (@key{#}), or
@t{mu4e} will ask you for it when you execute the marks (@key{x}).

@node Executing the marks
@section Executing the marks

After you have marked some messages, you can execute them with @key{x}
(@code{mu4e-mark-execute-all}).

@node Leaving the headers buffer
@section Leaving the headers buffer

When you quit the buffer (for example, but doing a new search) with marks being
present, @t{mu4e} asks you what to do with them, depending on the value of the
variable @code{mu4e-headers-leave-behavior} -- see its documentation.

@node Custom mark functions
@section Custom mark functions

Sometimes, the built-in functions to mark messages may not be sufficient for
your needs. For this, @t{mu4e} offers an easy way to define your own custom
mark functions. You can choose one of the custom marker functions using
@key{&} in @ref{Headers view} and @ref{Message view}.

Custom mark functions should be appended to the list
@code{mu4e-headers-custom-markers}. Each of the elements of this list
('markers') is a list with three (or two) elements:
@itemize
@item The name of the marker - as short string describing this marker. The
first character of this string will also be its shortcut, so these should be
unique.
@item a predicate function taking two arguments @t{msg} and @t{param}- first,
@t{msg}, which is the message
plist (see @ref{The message s-expression}); second is a parameter provided by
the third of the marker elements (next item). The predicate function should
return non-nil if the messages matches.
@item (optionally) a function that is evaluated once, and its result is passed as a
parameter to the predicate function. This is useful to ask for user-input.
@end itemize

So, let's look at an example: suppose we want to match all messages that have
more than @emph{n} recipients. We could do it like this:

@lisp
(add-to-list 'mu4e-headers-custom-markers
  '("More than n recipients"
      (lambda (msg n) (> (+ (length (mu4e-msg-field msg :to))
                            (length (mu4e-msg-field msg :cc))) n))
      (lambda () (read-number "Match messages with more recipients than: "))) t)
@end lisp

After evaluating this, pressing @key{&} should let you choose the custom
marker function, and ask you for the parameters.

As you can see, it's not very hard to define simple functions to match
messages. There are some more examples in the defaults for
`mu4e-headers-custom-markers'; see @file{mu4e-headers.el}.

@node Some marking examples
@section Some marking examples

Let's look at some examples, assuming the default key-bindings.

@itemize
@item @emph{Mark the message at point for trashing}: press @key{d}
@item @emph{Mark all messages in the buffer as unread}: press @key{C-x h o}
@item @emph{Delete the messages in the current thread}: press @key{T D}
@item @emph{Mark messages with a subject matching ``hello'' for flagging}:
press @key{% + s hello RET}. Note, the menu system helps you here; all you
need to remember is @key{%} for @code{mu4e-headers-mark-pattern}.
@end itemize


@node Actions
@chapter Actions

@t{mu4e} allows you to define custom actions for messages in the @ref{Headers
view} and for both messages and attachments in the @ref{Message view}. Custom
actions allow you to easily extend @t{mu4e} for specific needs -- for example,
marking messages as spam in a spam filter or applying an attachment with a
source code patch.

You can invoke the actions with @key{a} for actions on messages, and @key{A}
for actions on attachments. In the following, we'll gives some examples of
defining actions.

Note, the format of the actions has changed since version 0.9.8.4, and you
must change your configuration to use the new format; @t{mu4e} warns you when
you are using the old format.

The older format was: @code{(DESCRIPTION SHORTCUT [VALUE])}, while the new
format is a cons-cell, @code{(DESCRIPTION . VALUE)}; see below for some
examples. If your shortcut is not also the first character of the description,
simply prefix the description with that character.

@subsection Functions for actions

Defining a new custom action means that you need to write an elisp-function to
do the work. Functions that operate on messages look like:
@lisp
(defun my-action-func (msg)
 "Describe my func."
;; do stuff
)
@end lisp

Messages that operate on attachments look like:
@lisp
(defun my-attachment-action-func (msg attachment-num)
 "Describe my func."
;; do stuff
)
@end lisp

After you have defined your function, you can add it to the list of actions,
either @code{mu4e-headers-actions}, @code{mu4e-view-actions} or
@code{mu4e-view-attachment-actions}.

Let's take a at some simple examples.

@subsection Example: adding an action in the headers view

Suppose we would like to inspect the number of recipients for a message in the
@ref{Headers view}.  We could define the following function in our configuration:

@lisp
(defun show-number-of-recipients (msg)
  "Display the number of recipients for this message."
  (message "Number of recipients: %d"
     (+ (length (mu4e-msg-field msg :to)) (length (mu4e-msg-field msg :cc)))))

;; define 'N' (the first letter of the description) as the shortcut
(add-to-list 'mu4e-headers-actions
   '("Number of recipients" . show-number-of-recipients) t)
@end lisp

After activating this, @key{a n} in the headers view will show the number of
recipients for the message at point.

@subsection Example: adding an action in the message view

As another example, suppose we would like to search for messages by the sender
of this message.

@lisp
(defun search-for-sender (msg)
  "Search for messages sent by the sender of the current one."
  (mu4e-headers-search (concat "from:" (cdar (mu4e-msg-field msg :from)))))

;; define 'x' as the shortcut
(add-to-list 'mu4e-view-actions
   '("xsearch for sender" . search-for-sender) t)
@end lisp

@subsection Example: adding an attachment action

Finally, let's define an action for an attachment. As mentioned,
attachment-action function take @emph{2} arguments, the message and the
attachment number to use.

The following will count the number of lines in an attachment, and define
@key{n} as the shortcut key (the 'n' is prefixed to the description).

@lisp
(defun count-lines-in-attachment (msg attachnum)
  "Count the number of lines in an attachment."
  (mu4e-view-pipe-attachment msg attachnum "wc -l"))
(add-to-list 'mu4e-view-attachment-actions
   '("ncount lines" . count-lines-in-attachment) t)
@end lisp

@subsection What functions are available?

@t{elisp} does not have a module-system, so it can be hard to see what
functions are internal, and which are usable for others as well.

To help a bit with this, all functions and variables in @t{mu4e} marked for
@emph{internal} use have the prefix @t{mu4e~}, while all the public ones use
@t{mu4e-}. The @t{~} was chosen because its ascii-code is after all the
letters, so they will only appear at the end of completion buffers and the
like.

Functions that start with @t{mu4e-view-} and @t{mu4e-headers-} should be
called only from that particular context (the message view and the headers
view, respectively).

@subsection Example actions

@t{mu4e} includes a number of example actions in @file{mu4e-actions.el} in the
source distribution (see @key{C-h f mu4e-action-TAB}). For example, for
viewing messages in an external web browser, or listening to a message's
body-text using text-to-speech.

If you have come up with any interesting actions that may be useful for
others, you are invited to contribute those.

@node Interaction with other tools
@chapter Interaction with other tools

In this chapter we discuss some ways in ways in which @t{mu4e} can cooperate
with other tools.

@menu
* Setting the default emacs mail program::
* Creating org-mode links::
* Rich-text messages with org-mode::
* Maintaining an address-book with org-contacts::
* Getting new mail notifications with Sauron::
* Speedbar support::
* Citations with mu-cite::
* Attaching files with dired::
@end menu

@node Setting the default emacs mail program
@section Setting the default emacs mail program

@t{emacs} allows you to select an e-mail program as the default program it
will use when you press @key{C-x m} (@code{compose-mail}), call
@code{report-emacs-bug} and so on.

If you want to use @t{mu4e} for this, you do so by adding the following to
your configuration:

@lisp
(setq mail-user-agent 'mu4e-user-agent)
@end lisp

At the present time, support is still experimental.

@node Creating org-mode links
@section Creating org-mode links
It can be useful to include links to e-mail messages or even search queries in
your org-mode files. @t{mu4e} supports this with the @t{org-mu4e} module; you
can set it up by adding it to your configuration:

@lisp
(require 'org-mu4e)
@end lisp

After this, you can use the normal @t{org-mode} mechanisms to store links:
@t{M-x org-store-link} will store a link to a particular message when you're
in @ref{Message view}, and a link to a query when you are in @ref{Headers
view}.

You can insert these link later with @t{M-x org-insert-link}. Then, you can go
to the query or message the link points to with either @t{M-x
org-agenda-open-link} in agenda buffers, or @t{M-x org-open-at-point}
elsewhere - both are typically bound to @kbd{C-c C-o}.

@node Rich-text messages with org-mode
@section Rich-text messages with org-mode (EXPERIMENTAL)

@t{org-mode} has some nice facilities for editing texts -- creating lists,
tables, mathematical formulae etc. In addition, it can convert them to
@abbr{HTML}.

An @emph{experimental} @t{mu4e} feature lets you edit your messages with
@t{org-mode}, and (optionally) convert them on the fly (when sending them) to
messages with an HTML-part containing the rich-text version of your messages.

To enable all this, make sure you have
@lisp
(require 'org-mu4e)
@end lisp
somewhere in your setup, and also make sure that the @t{dvipng} program is
available in your path.

Then, when composing a message, you can use @code{M-x
org-mu4e-compose-org-mode} to enable this mode, or, alternatively, put in the
mode-hook for @t{mu4e-compose-mode}.

@t{org-mu4e-compose-org-mode} behaves more or less like a minor-mode. When it
is active, editing the message body takes place in @t{org-mode}, while editing
the headers uses the normal message editing mode, @t{mu4e-compose-mode}.

Now, if you want to automatically convert the @t{org-mode} markup to rich-text
when sending messages, you need to set the variable
@code{org-mu4e-convert-to-html} to non-nil:

@lisp
(setq org-mu4e-convert-to-html t)
@end lisp

To send the message or execute other @t{mu4e-compose-mode}/@t{message-mode}
commands on the message, first press @key{M-m}. Thus, for example, to send the
message, you'd press @key{M-m C-c}.

The code for doing the conversion is based on Eric Schultze's
@t{org-mime}@footnote{@url{http://orgmode.org/worg/org-contrib/org-mime.php}},
but has been customized for use with @t{mu4e}. In particular, the
mode-switching between @t{org-mode} and @t{mu4e-compose-mode} is
@t{mu4e-specific}.

@node Maintaining an address-book with org-contacts
@section Maintaining an address-book with org-contacts

Note, @t{mu4e} supports built-in address autocompletion; @ref{Address
autocompletion}, and that is the recommended way to do this.

However, it is also possible to manage your addresses with @t{org-mode}, using
@t{org-contacts}@footnote{@url{http://julien.danjou.info/software/org-contacts.el}}.

@t{mu4e-actions} defines a useful action (@ref{Actions}) for this to add a
contact based on the @t{From:}-address in the current mail (current header or
view). To enable this, add to your configuration something like:

@lisp
(setq mu4e-org-contacts-file  <full-path-to-your-org-contacts-file>)
(add-to-list 'mu4e-headers-actions
  '("org-contact-add" . mu4e-action-add-org-contact) t)
(add-to-list 'mu4e-view-actions
  '("org-contact-add" . mu4e-action-add-org-contact) t)
@end lisp

After this, you should be able to add contacts using @key{a o} in the headers
view and the message view, using the @t{org-capture} mechanism. Note, the
@key{o} is because of the first character of @t{org-contact-add}.

@node Getting new mail notifications with Sauron
@section Getting new mail notifications with Sauron

The emacs-package Sauron@footnote{Sauron can be found at
@url{https://github.com/djcb/sauron}, or in the Marmalade package-repository
at @url{http://http://marmalade-repo.org/}} (by the same author) can be used
to get notifications about new mails.

If you put something like the below script in your @t{crontab} (or have some
other way of having it execute every @emph{n} minutes, you will receive
notifications in the sauron-buffer when new messages arrive.

@verbatim
#!/bin/sh
# put the path to your Inbox folder here

CHECKDIR="/home/$LOGNAME/Maildir/Inbox"
sauron-msg () {
    DBUS_COOKIE="/home/$LOGNAME/.sauron-dbus"
    if test "x$DBUS_SESSION_BUS_ADDRESS" = "x"; then
        if test -e $DBUS_COOKIE; then
                export DBUS_SESSION_BUS_ADDRESS="`cat $DBUS_COOKIE`"
        fi
    fi
    if test -n "x$DBUS_SESSION_BUS_ADDRESS"; then
        dbus-send --session                          \
            --dest="org.gnu.Emacs"                   \
            --type=method_call                       \
            "/org/gnu/Emacs/Sauron"                  \
            "org.gnu.Emacs.Sauron.AddMsgEvent"       \
            string:shell uint32:3 string:"$1"
    fi
}

for f in `find $CHECKDIR -mmin -2 -a -type f`; do
        subject=`$MU view $f | grep '^Subject:' | sed 's/^Subject://'`
        sauron-msg "mail: $subject"
done
@end verbatim

Note, you should put something like:
@lisp
(setq sauron-dbus-cookie t)
@end lisp
in your setup, which allows the script to find the D-Bus session bus.

@node Speedbar support
@section Speedbar support

@code{speedbar} is an emacs-extension that shows navigational information for
an emacs buffer in a separate frame. Using @code{mu4e-speedbar}, @t{mu4e}
lists your bookmarks and maildir folders and allows for one-click access to
them.

@t{mu4e} loads @t{mu4e-speedbar} automatically; all you need to do to activate
it is @code{M-x speedbar}. Then, when then going to the @ref{Main view}, the
speedbar-frame will be updated with your bookmarks and maildirs. For speed
reasons, the list of maildirs is determined when @t{mu4e} starts; if the list
of maildirs changes while @t{mu4e} is running, you need to restart @t{mu4e} to
reflect those changes in the speedbar and in other places that use this list,
such as auto-completion when jumping to a maildir.

@code{mu4e-speedbar} was contributed by Antono Vasiljev.

@node Citations with mu-cite
@section Citations with @t{mu-cite}

Note, apart from its name @t{mu-cite} is a project totally unconnected to
@t{mu}/@t{mu4e}.

@t{mu-cite} is a package to control the way message citations look like (i.e.,
the message you responded to when you reply to them or forward them), with its
latest version available at @url{http://www.jpl.org/elips/mu/}.

After installation of the @t{mu-cite}, you can use something like the
following to make it work with @t{mu4e}:

@lisp
(require 'mu-cite)
(setq message-cite-function 'mu-cite-original)
(setq mu-cite-top-format
    '("On " date ", " full-name " wrote:\n\n"))
(setq mu-cite-prefix-format '(" > ")))
@end lisp

@node Attaching files with dired
@section Attaching files with @t{dired}

It's possible to attach files to @t{mu4e} messages, using the following steps
(based on a post on the @t{mu-discuss} mailing list by Stephen Eglen).

To prepare for this, you need a special version of the @code{gnus-dired-mail-buffers}
function so it understands @t{mu4e} buffers as well; so put in your
configuration:

@lisp
(require 'gnus-dired)
;; make the `gnus-dired-mail-buffers' function also work on message-mode derived
;; modes, such as mu4e-compose-mode
(defun gnus-dired-mail-buffers ()
  "Return a list of active message buffers."
  (let (buffers)
    (save-current-buffer
      (dolist (buffer (buffer-list t))
	(set-buffer buffer)
	(when (and (derived-mode-p 'message-mode)
		(null message-sent-message-via))
	  (push (buffer-name buffer) buffers))))
    (nreverse buffers)))

(setq gnus-dired-mail-mode 'mu4e-user-agent)
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
@end lisp

Then, mark the file(s) in @t{dired} you would like to attach and press @t{C-c
RET C-a}, and you'll be asked whether to attach them to an existing message,
or create a new one.


@node Example configuration
@chapter Example configuration

In this chapter, we show some example configurations.

@menu
* Minimal configuration::
* Longer configuration::
* Gmail configuration::
@end menu


@node Minimal configuration
@section Minimal configuration

An (almost) minimal configuration for @t{mu4e} might look something like this:

@lisp
;; example configuration for mu-for-emacs (mu4e)
(require 'mu4e)

;; happily, below settings are all /optional/

;; Only needed if your maildir is _not_ ~/Maildir
;;(setq mu4e-maildir "/home/user/Maildir")

;; these must start with a "/", and must exist
;; (i.e.. /home/user/Maildir/sent must exist)
;; you use e.g. 'mu mkdir' to make the Maildirs if they don't
;; already exist

;; below are the defaults; if they do not exist yet, mu4e will offer to
;; create them
;; (setq mu4e-sent-folder   "/sent")
;; (setq mu4e-drafts-folder "/drafts")
;; (setq mu4e-trash-folder  "/trash")

;; for the settings for outgoing mail consult the section 'Longer configuration'
@end lisp


@node Longer configuration
@section Longer configuration

@lisp
;; example configuration for mu-for-emacs (mu4e)
(require 'mu4e)

(setq
   ;; a regular expression that matches all email address uses by the user;
   ;; this allows us to correctly determine if user is the sender of some message
   mu4e-user-mail-address-regexp
      "foo@@bar\.com\\|cuux@@example\.com"

   ;; path to our Maildir directory
   mu4e-maildir       "/home/user/Maildir"
   ;; the next are relative to `mu4e-maildir'
   mu4e-sent-folder   "/sent"
   mu4e-drafts-folder "/drafts"
   mu4e-trash-folder  "/trash"

   ;; the maildirs you use frequently; access them with 'j' ('jump')
   mu4e-maildir-shortcuts
    '( ("/archive"     . ?a)
       ("/inbox"       . ?i)
       ("/work"        . ?w)
       ("/sent"        . ?s))

   ;; when you want to use some external command for text->html conversion,
   ;; i.e., the 'html2text' program
   mu4e-html2text-command "html2text"

   ;; the headers to show in the headers list -- a pair of the field + its
   ;; width, with `nil' meaning 'unlimited' (better only use that for
   ;; the last field. These are the defaults:
   mu4e-headers-fields
    '( (:date          .  25)
       (:flags         .   6)
       (:from          .  22)
       (:subject       .  nil))

   ;; program to get mail; alternatives are 'fetchmail', 'getmail'
   ;; isync or your own shellscript. called when 'U' is pressed in
   ;; main view
   mu4e-get-mail-command "offlineimap"

   ;; general emacs mail settings; used when composing e-mail
   mu4e-reply-to-address "foo@@bar.com"
   user-mail-address "foo@@bar.com"
   user-full-name  "Foo X. Bar"

   ;; include in message with C-c C-w
   message-signature
    (concat
      "Foo X. Bar\n"
      "http://www.example.com\n")

   ;; smtp mail setting
   message-send-mail-function 'smtpmail-send-it
   smtpmail-default-smtp-server "smtp.example.com"
   smtpmail-smtp-server ""smtp.example.com"
   smtpmail-local-domain "example.com"

   ;; if you need offline mode, set these -- and create the queue dir
   ;; with 'mu mkdir', i.e.. mu mkdir /home/user/Maildir/queue
   smtpmail-queue-mail  nil
   smtpmail-queue-dir  "/home/user/Maildir/queue/cur")

   ;; don't keep message buffers around
   (setq message-kill-buffer-on-exit t)
@end lisp


@node Gmail configuration
@section Gmail configuration

@emph{Gmail} is a popular e-mail provider; let's see how we can make it work
with @t{mu4e}.

First of all, we need a program to get the e-mail from Gmail to our local
machine; for this we use @t{offlineimap}; on Debian (and derivatives like
Ubuntu), this is as easy as:
@verbatim
sudo apt-get install offlineimap
@end verbatim

Then, we need to create a configuration for @t{offlineimap}, i.e. a file
@file{~/.offlineimaprc}:

@verbatim
[general]
accounts = Gmail
maxsyncaccounts = 3

[Account Gmail]
localrepository = Local
remoterepository = Remote

[Repository Local]
type = Maildir
localfolders = ~/Maildir

[Repository Remote]
type = IMAP
remotehost = imap.gmail.com
remoteuser = USERNAME@gmail.com
remotepass = PASSWORD
ssl = yes
maxconnections = 1
realdelete = no
@end verbatim

Obviously, you need to replace @t{USERNAME} and @t{PASSWORD} with your actual
Gmail username and password.

After this, you should be able to download your mail:
@verbatim
$ offlineimap
 OfflineIMAP 6.3.4
Copyright 2002-2011 John Goerzen & contributors.
Licensed under the GNU GPL v2+ (v2 or any later version).

Account sync Gmail:
 ***** Processing account Gmail
 Copying folder structure from IMAP to Maildir
 Establishing connection to imap.gmail.com:993.
Folder sync [Gmail]:
 Syncing INBOX: IMAP -> Maildir
 Syncing [Gmail]/All Mail: IMAP -> Maildir
 Syncing [Gmail]/Drafts: IMAP -> Maildir
 Syncing [Gmail]/Sent Mail: IMAP -> Maildir
 Syncing [Gmail]/Spam: IMAP -> Maildir
 Syncing [Gmail]/Starred: IMAP -> Maildir
 Syncing [Gmail]/Trash: IMAP -> Maildir
Account sync Gmail:
 ***** Finished processing account Gmail
@end verbatim

We can now run @t{mu} to make sure things work:

@verbatim
$ mu index
mu: indexing messages under /home/foo/Maildir [/home/foo/.mu/xapian]
| processing mail; processed: 520; updated/new: 520, cleaned-up: 0
mu: elapsed: 3 second(s), ~ 173 msg/s
mu: cleaning up messages [/home/foo/.mu/xapian]
/ processing mail; processed: 520; updated/new: 0, cleaned-up: 0
mu: elapsed: 0 second(s)
@end verbatim

Note that we can run both the @t{offlineimap} and the @t{mu index} from within
@t{mu4e}, but running it from the command line makes it a bit easier to see
what is going on.

Now, let's make a @t{mu4e} configuration for this:

@lisp
(require 'mu4e)

;; default
;; (setq mu4e-maildir (expand-file-name "~/Maildir"))

(setq mu4e-drafts-folder "/[Gmail].Drafts")
(setq mu4e-sent-folder   "/[Gmail].Sent Mail")
(setq mu4e-trash-folder  "/[Gmail].Trash")

;; don't save message to Sent Messages, Gmail/IMAP will take care of this
(setq mu4e-sent-messages-behavior 'delete)

;; setup some handy shortcuts
(setq mu4e-maildir-shortcuts
    '( ("/INBOX"               . ?i)
       ("/[Gmail].Sent Mail"   . ?s)
       ("/[Gmail].Trash"       . ?t)
       ("/[Gmail].All Mail"    . ?a)))

;; allow for updating mail using 'U' in the main view:
(setq mu4e-get-mail-command "offlineimap")

;; something about ourselves
(setq
   user-mail-address "USERNAME@@gmail.com"
   user-full-name  "Foo X. Bar"
   message-signature
    (concat
      "Foo X. Bar\n"
      "http://www.example.com\n"))

;; sending mail -- replace USERNAME with your gmail username
;; also, make sure the gnutls command line utils are installed
;; package 'gnutls-bin' in Debian/Ubuntu

(require 'smtpmail)
(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-stream-type 'starttls
      smtpmail-default-smtp-server "smtp.gmail.com"      
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587)

;; don't keep message buffers around
(setq message-kill-buffer-on-exit t)
@end lisp

And that's it -- put the above in your @file{~/.emacs} (obviously you need to
change @t{USERNAME} etc. to your own), and restart @t{emacs}, and run @kbd{M-x
mu4e}.

Using these settings, you can quickly switch to your Inbox -- press
@kbd{ji}. Then, when you want archive some messages, move them to the 'All
Mail' folder by pressing @kbd{ma}.


@node FAQ - Frequently Anticipated Questions
@chapter FAQ - Frequently Anticipated Questions

In this chapter we list a number of actual and anticipated questions and their
answers.

@itemize
@item @emph{How can I quickly delete/move/trash a lot of messages?} You can
select ('mark' in emacs-speak) the messages like you would select text in a
buffer; the actions you then take (e.g., @key{DEL} for delete, @key{m} for
move and @key{t} for trash) will apply to @emph{all} selected messages. You
can also use functions like @code{mu4e-headers-mark-thread} (@key{T}),
@code{mu4e-headers-mark-subthread} (@key{t}) to mark whole threads at the same
time, and @code{mu4e-headers-mark-pattern} (@key{%}) to mark all messages
matching a certain regular expression.
@item @emph{How can I use @t{BBDB}?} Currently, there is no built-in for
address management with @t{BBDB}; instead, we recommend using @t{mu4e}'s
built-in @ref{Address autocompletion}.
@item @emph{mu4e seems to return a mere subset of all matches - how can I get
all?}. Indeed, for speed reasons (and because, if you are like the author, you
usually don't need thousands of matches), @t{mu4e} returns only up to the
value of the variable @code{m4ue-search-result-limit} matches. To show
@emph{all} results, use @t{M-x mu4e-headers-toggle-full-search}, or customize
the variable @code{mu4e-headers-full-search}. This applies to all search
commands.
@item @emph{How can I show attached images in my message view buffers?} See
@ref{Viewing images inline}.
@item @emph{How can I easily include attachments in the messages I write?}
You can drag-and-drop from your desktop; alternatively, you can use @t{dired}
-- see @ref{Attaching files with dired}.
@item @emph{@t{mu4e} seems to remove myself from the Cc: list; how can I
prevent that?}
Set @code{mu4e-compose-keep-self-cc} to @t{t} in your configuration.
@item @emph{When I try to run @t{mu index} while @t{mu4e} is running I get
errors like @t{mu: mu_store_new_writable: xapian error 'Unable to get write
lock on ~/.mu/xapian: already locked'}. What can I do about this?} You get
this error because the underlying Xapian database allows itself to be opened
in read-write mode only once. There is not much @t{mu4e} can do about this,
but what you can do is telling @t{mu} to (gracefully) terminate:

@verbatim
   pkill -2 -u $UID mu # send SIGINT
   sleep 1
   mu index
@end verbatim

@t{mu4e} will automatically restart @t{mu} when it needs it. In practice, this
seems to work quite well.
@item @emph{Can I automatically apply the marks on messages when
leaving the headers buffer?} Yes you can -- see the documentation on
@t{mu4e-headers-leave-behavior}.
@item @emph{How can I automatically apply word-wrapping (and hiding cited
parts) when viewing a message?} See the documentation on
@t{mu4e-view-wrap-lines} (and @t{mu4e-view-hide-cited}). You can always toggle
between the two states with @key{w} and @key{h}, respectively.
@item @emph{Is there context-sensitive help available?} Yes - pressing @key{H}
should take you to the right place in this manual.
@item @emph{How can I set @t{mu4e} as the default e-mail client in emacs?}
See @ref{Setting the default emacs mail program}.
@item @emph{How can I perform custom actions on messages and attachments?} See
@ref{Actions}.
@end itemize

@node Known issues / missing features
@chapter Known issues / missing features

In this chapter we list a number of known issue and/or missing features in
@t{mu4e}. Thus, users won't have to search in vain for things that are not
there (yet), and the author can use it as a todo-list.

@itemize
@item @emph{mu4e does not work well if the emacs language environment is not
utf-8}; so, if you problems with encodings, be sure to have
@code{(set-language-environment "UTF-8")} in your @file{.emacs}.
@item @emph{Thread handling is incomplete.} While threads are calculated and are
visible in the headers buffer, you can not collapse/open them.
@item @emph{No support for crypto when reading mail}. Currently, you cannot
conveniently read encrypted mail or check signatures. For outgoing messages,
it should work though, using the built-in mechanisms.
@item @emph{The key-bindings are @emph{somewhat} hard-coded} That is, the main
menu assumes the default key-bindings, as do the clicks-on-bookmarks.
@end itemize


@node How it works
@appendix How it works

While not necessarily interesting for all users of @t{mu4e}, for some it may
be interesting to know how @t{mu4e} does its job.

@menu
* High-level overview::
* mu server::
* The message s-expression::
* Reading from the server::
@end menu

@node High-level overview
@section High-level overview

On a high level, we can summarize the structure of the @t{mu4e} system using
some ascii-art:

@example
              +---------+
              | emacs   |
              |    +------+
              +----| mu4e | --> send mail (smtpmail)
                   +------+
                    |  A
                    V  |  ---/ search, view, move mail
              +---------+    \
              |   mu    |
              +---------+
                |    A
                V    |
              +---------+
              | Maildir |  <--- receive mail (fetchmail,
              +---------+                     offlineimap, ...)
@end example

In words:
@itemize

 @item Your e-mail messages are stored in a Maildir-directory (typically,
 @file{~/Maildir}), and new mail comes in using tools like @t{fetchmail},
 @t{offlineimap}, or through a local mail servers (such as @t{qmail} or
 Postfix).

 @item @t{mu} indexes these messages periodically, so you can quickly
 search for them. @t{mu} can run in a special @t{server}-mode, where it
 provides services to client software.

 @item @t{mu4e}, which runs inside @t{emacs} is such a client; it communicates
 with @t{mu} (in its @t{server}-mode to search for messages, and manipulate
 them.

 @item @t{mu4e} uses the facilities offered by @t{emacs} (the
 Gnus message editor and @t{smtpmail}) to send messages.

@end itemize

@node mu server
@section @t{mu server}

@t{mu4e} is based on the @t{mu} e-mail searching/indexer. The latter is a
C-program; there are different ways to communicate with a client that is
emacs-based.

One way to implement this, would be to call the @t{mu} command-line tool with
some parameters and then parse the output. In fact, that is how some tools do
it, and it was the first approach -- @t{mu4e} would invoke e.g., @t{mu find}
and process the output in emacs.

However, with approach, we need to load the entire e-mail @emph{Xapian}
database (in which the message is stored) for each invocation. Wouldn't it be
nicer to keep a running @t{mu} instance around?  Indeed, it would - and thus,
the @t{mu server} sub-command was born. Running @t{mu server}, you get a
sort-of shell, in which you can give commands to @t{mu}, which will then spit
out the results/errors. @t{mu server} is not meant for humans, but it can be
used manually, which is great for debugging.

@node Reading from the server
@section Reading from the server

In the design, the next question was what format @t{mu} should use for its
output for @t{mu4e} (@t{emacs}) to process. Some other programs use
@abbr{JSON} here, but it seemed easier (and possibly, more efficient) just to
talk to @t{emacs} in its native language: @emph{s-expressions} (to be precise:
@emph{plists}), and interpret those using the @t{emacs}-function
@code{read-from-string}. See @ref{The message s-expression} for details on the
format.

So, now let's look how we process the data from @t{mu server} in emacs. We'll
leave out a lot of detail, @t{mu4e}-specifics, and look at a bit more generic
approach.

The first thing to do is to create a process (for example, with
@code{start-process}), and then register a filter function for it, which will
be invoked whenever the process has some data for us. Something like:

@lisp
  (let ((proc (start-process <arguments>)))
    (set-process-filter proc 'my-process-filter)
    (set-process-sentinel proc 'my-process-sentinel))
@end lisp

Note, the process sentinel is invoked when the process is terminated -- so there
you can clean things up.

The function =my-process-filter= is a user-defined function that takes the
process and the chunk of output as arguments; in @t{mu4e} it looks something like
(pseudo-lisp):

@lisp
(defun my-process-filter (proc str)
  ;; mu4e-buf: a global string variable to which data gets appended
  ;; as we receive it
  (setq mu4e-buf (concat mu4e-buf str))
  (when <we-have-received-a-full-expression>
      <eat-expression-from mu4e-buf>
      <evaluate-expression>))
@end lisp

@code{<evaluate-expression>} de-multiplexes the s-expression we got. For
example, if the s-expression looks like an e-mail message header, it will be
processed by the header-handling function, which will append it to the header
list. If the s-expression looks like an error message, it will be reported to
the user. And so on.

The language between frontend and backend is documented in the @t{mu-server}
man-page. @t{mu4e} can log these communications; you can use @code{M-x
mu4e-toggle-logging} to turn logging on and off, and you can view the log
using @code{M-x mu4e-show-log}.

@node The message s-expression
@section The message s-expression

A typical message s-expression looks something like the following:

@lisp
(:docid 32461
 :from (("Nikola Tesla" . "niko@@example.com"))
 :to (("Thomas Edison" . "tom@@example.com"))
 :cc (("Rupert The Monkey" . "rupert@@example.com"))
 :subject "RE: what about the 50K?"
 :date (20369 17624 0)
 :size 4337
 :message-id "6BDC23465F79238C8233AB82D81EE81AF0114E4E74@@123213.mail.example.com"
 :path  "/home/tom/Maildir/INBOX/cur/133443243973_1.10027.atlas:2,S"
 :maildir "/INBOX"
 :priority normal
 :flags (seen)
 :parts ( (:index 1 :mime-type "text/plain" :size 12345 :attachment nil)
          (:index 2 :name "photo.jpg" :mime-type "image/jpeg" :size 147331 :attachment t)
          (:index 3 :name "book.pdf" :mime-type "application/pdf" :size 192220 :attachment t))
 :references  ("6BDC23465F79238C8384574032D81EE81AF0114E4E74@@123213.mail.example.com"
 "6BDC23465F79238203498230942D81EE81AF0114E4E74@@123213.mail.example.com")
 :in-reply-to "6BDC23465F79238203498230942D81EE81AF0114E4E74@@123213.mail.example.com"
 :body-txt "Hi Tom,
 ....
"))
@end lisp

This s-expression forms a property list (@t{plist}), and we can get values
from it using @t{plist-get}; for example @code{(plist-get msg :subject)} would
get you the message subject. However, it's better to use the function
@code{mu4e-msg-field} to shield you from some of the implementation details
that are subject to change.

Some notes on the format:
@itemize
@item The address fields are @emph{lists} of pairs @code{(name . email)},
where @t{name} can be nil.
@item The date is in format emacs uses (for example in
@code{current-time}).@footnote{Emacs 32-bit integers have only 29 bits
available for the actual number; the other bits are use by emacs for internal
purposes. Therefore, we need to split @t{time_t} in two numbers.}
@item Attachments are a list of elements with fields @t{:index} (the number of
the MIME-part), @t{:name} (the file name, if any), @t{:mime-type} (the
MIME-type, if any) and @t{:size} (the size in bytes, if any).
@item Messages in the @ref{Headers view} come from the database and do not have
@t{:attachments}. @t{:body-txt} or @t{:body-html} fields. Message in the
@ref{Message view} use the actual message file, and do include these fields.
@end itemize

@subsection Example: ping-pong

As an example of this, let's look at the @t{ping-pong}-sequence. When @t{mu4e}
starts, it sends a command @t{ping} to the the @t{mu server} backend, to learn
about its version. @t{mu server} then responds with a @t{pong} s-expression to
provide this information (this is implemented in @file{mu-cmd-server.c}).

We start this sequence when @t{mu4e} is invoked (when the program is
started). It call @t{mu4e-proc-ping}, and registers a (lambda) function for
@t{mu4e-proc-pong-func}, so it will retrieve the response.

@verbatim
-> ping
<- (pong "mu" :version "x.x.x" :doccount 10000)
@end verbatim

When we receive such a @t{pong} (in @file{mu4e-proc.el}), the lambda function
we registered will be called, and it check the version we got from the
@t{pong} with the version we expected, and raises an error, if they differ.

@node Logging and debugging
@appendix Logging and debugging

As explained in @ref{How it works}, @t{mu4e} communicates with its backend
(@t{mu server}) by sending commands and receiving responses (s-expressions).

For debugging purposes, it can be very useful to see this data. For this
reason, @t{mu4e} can log all these messages. Note that the 'protocol' is
documented to some extent in the @t{mu-server} manpage.

You can enable (and disable) logging with @t{M-x mu4e-toggle-logging}. The
log-buffer is called @t{*mu4e-log*}, and in the @ref{Main view},
@ref{Headers view} and @t{Message view}, there's a keybinding @key{$} that
will take you there. You can quit it by pressing @key{q}.

Logging can be a bit resource-intensive, so you may not want to leave it on
all the time. By default, the log only maintains the most recent 1200 lines.

Note, @t{mu} itself keeps a log as well, you can find this it in
@t{<MUHOME>/log/mu.log}, typically @t{~/.mu/log/mu.log}.

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi

@bye
